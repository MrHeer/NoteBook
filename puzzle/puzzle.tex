% !TEX program = pdflatex
% !TEX options = --shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
\documentclass[12pt]{article}

\usepackage[ruled]{algorithm2e}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}

\hypersetup{
colorlinks=true,
linkcolor=black
}
\numberwithin{equation}{section}

\title{The Puzzles of MrHeer}
\author{MrHeer}
\date{\today}
 
\begin{document}

\begin{titlepage}
    \maketitle
    \thispagestyle{empty}
\end{titlepage}

\begin{center}
    \tableofcontents
\end{center}
\pagenumbering{roman}

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\section{Throwing eggs from a building}
\subsection*{Question}
Suppose that you have an $N$-story building and
plenty of eggs. Suppose also that an egg is broken if it is thrown off floor $F$ or higher,
and unhurt otherwise. First, devise a strategy to determine the value of $F$ such that the
number of broken eggs is $\sim$$\lg{N}$ when using $\sim$$\lg{N}$ throws, then find a way to reduce the
cost to $\sim$$2\lg{F}$.
\subsection*{Answer}
$\sim$$\lg{N}$: start at the middle, always cut search space in half $\rightarrow$ binary search.\\
$\sim$$2\lg{F}$: start at 1, next 2, 4, 8 (i.e., $2^i$), once the egg breaks after ($\sim$$\lg{F}$ steps)
do binary search in the smaller search space (range $<$ $F$ and hence number of searches $<$ $\sim$$\lg{F}$)
$\rightarrow$ exponential search.
\[2^{\lceil \lg{F} \rceil - 1} < F \leqslant 2^{\lceil \lg{F} \rceil}\]
\[range = 2^{\lceil \lg{F} \rceil} - 2^{\lceil \lg{F} \rceil - 1}
= 2^{\lceil \lg{F} \rceil - 1} < 2^{\lg{F}} = F\]
\[range < F\]

\newpage
\section{Throwing two eggs from a building}
\subsection*{Question}
Consider the previous question, but now
suppose you only have two eggs, and your cost model is the number of throws. Devise
a strategy to determine $F$ such that the number of throws is at most $2\sqrt{N}$, then find a
way to reduce the cost to $\sim$$c\sqrt{F}$. This is analogous to a situation where search hits (egg
intact) are much cheaper than misses (egg broken).
\subsection*{Answer}
Let us make our first attempt on $k$'th floor.
If it breaks, we try remaining $(k-1)$ floors one by one. 
So in worst case, we make $k$ trials.
If it doesn’t break, we jump $(k-1)$ floors (Because we have
already made one attempt and we don't want to go beyond 
$k$ attempts. Therefore $(k-1)$ attempts are available),
Next floor we try is floor $k + (k-1)$
Similarly, if this drop does not break, next need to jump 
up to floor $k + (k-1) + (k-2)$, then $k + (k-1) + (k-2) + (k-3)$
and so on.
Since the last floor to be tried is $F$'th floor, sum of
series should be $F$ for optimal value of $k$.
\[k + (k-1) + (k-2) + (k-3) + \cdots + 1 \geqslant F\]
\[\frac{k(k+1)}{2} \geqslant F\]
\[k \geqslant \frac{\sqrt{8F+1}-1}{2}\]
\[k_{min} = \lceil \frac{\sqrt{8F+1}-1}{2} \rceil \sim \sqrt{2F}\] 
\subsection*{Official solution}
Solution to Part 1: To achieve $2\sqrt{N}$, drop eggs at floors $\sqrt{N}$,
$2*\sqrt{N}$, $3*\sqrt{N}$, ..., $\sqrt{N}\sqrt{N}$. (For simplicity, we assume
here that $\sqrt{N}$ is an integer.) Let assume that the egg broke at level
$k\sqrt{N}$. With the second egg you should then perform a linear search in the
interval $(k-1)\sqrt{N}$ to $k\sqrt{N}$. In total you will be able to find the
floor $F$ in at most $2\sqrt{N}$ trials.\\
Hint for Part 2: $1 + 2 + 3 + \cdots + k \sim \frac{1}{2}k^2 \geqslant F$. 

\newpage
\section{3-collinearity}
\subsection*{Question}
Suppose that you have an algorithm that takes as input $N$ distinct
points in the plane and can return the number of triples that fall on the same line.
Show that you can use this algorithm to solve the 3-sum problem. Strong hint: Use
algebra to show that $(a, a^3)$, $(b, b^3)$, and $(c, c^3)$ are collinear if and only if $a + b + c = 0$.
\subsection*{Answer}
\begin{proof}
    $(a, a^3)$, $(b, b^3)$, and $(c, c^3)$ are collinear if and only if $a + b + c = 0$: \\
    We use a formulation of collinearity which equates gradients (assuming our points are distinct) 
    \[\frac{y_2-y_1}{x_2-x_1}=\frac{y_3-y_1}{x_3-x_1}\]
    This becomes
    \[\frac{b^3-a^3}{b-a}=\frac{c^3-a^3}{c-a}\]
    which leaves us with
    \[b^2+ab+a^2=c^2+ac+a^2\]
    so that
    \[b^2-c^2=a(c-b)\]
    $c \neq b$ so we have $a=-(b+c)$
    \[a+b+c=0\]
\end{proof}

\newpage
\section{Queue with three stacks [Unsolved]}
\subsection*{Question}
Implement a queue with three stacks so that each
queue operation takes a constant (worst-case) number of stack operations.
\subsection*{Answer}

\newpage
\section{Queue with two stacks}
\subsection*{Question}
Implement a queue with two stacks so that each queue
operation takes a constant amortized number of stack operations. Hint: If you push
elements onto a stack and then pop them all, they appear in reverse order. If you repeat
this process, they’re now back in order.
\subsection*{Answer}
\begin{algorithm}
    \NoCaptionOfAlgo
    \caption{Transfer}
    \KwResult{stack1 to stack2 and reverse order}
    \While{stack1 is not empty}{
        Item tmp = stack1.pop()\;
        stack2.push(tmp);
    }
\end{algorithm}

\begin{algorithm}
    \NoCaptionOfAlgo
    \caption{Enqueue}
    \KwIn{element item}
    \KwResult{enqueue}
    stack1.push(item);
\end{algorithm}

\begin{algorithm}
    \NoCaptionOfAlgo
    \caption{Dequeue}
    \KwResult{dequeue}
    \If{queue is empty}{
        throw NoSuchElementException;
    }
    \If{stack2 is empty}{
        transfer();
    }
    \Return stack2.pop();
\end{algorithm}

\subsection*{Code}
\inputminted{java}{QueueWithTwoStacks.java}

\subsection*{Analysis}
For $N$ items enqueue and dequeue.\\
enqueue: $N$ times push operations.\\
dequeue:\\
\indent transfer: $N$ times pop and $N$ times push  operations.\\
\indent dequeue: $N$ times pop operations.\\
total: $4N$ times stack operations.\\
So, the amortized number of stack operations is $\frac{4N}{N}=4$

\newpage
\section{Deque with a stack and a steque [Unsolved]}
\subsection*{Question}
Implement a deque with a stack and a steque
so that each deque operation takes a constant amortized number
of stack and steque operations.
\subsection*{Answer}

\newpage
\section{Deque with three stacks [Unsolved]}
\subsection*{Question}
Implement a deque with three stacks so that each
deque operation takes a constant amortized number of stack operations.
\subsection*{Answer}

\newpage
\section{Hot or cold}
\subsection*{Question}
Your goal is to guess a secret integer between 1 and $N$. You repeatedly 
guess integers between 1 and $N$. After each guess you learn if your guess equals the
secret integer (and the game stops). Otherwise, you learn if the guess is hotter (closer to)
or colder (farther from) the secret number than your previous guess. Design an algorithm
that finds the secret number in at most $\sim$$2\lg{N}$ guesses. Then design an algorithm
that finds the secret number in at most $\sim$$1\lg{N}$ guesses.
\subsection*{Answer}
$\sim$$2\lg{N}$: Suppose the secret between $[a, b]$, $mid=\frac{a+b}{2}$. First geuess $a$, then geuss $b$,
if $b$ hotter $a$, geuess $[mid, b]$, else guess $[a, mid]$...\\
$\sim$$1\lg{N}$: Suppose you know that your secret integer is in $[a,b]$, and that your last guess is $c$.
You want to divide your interval by two, and to know whether your secret integer lies in between $[a, m]$ or
$[m, b]$, with $m=\frac{a+b}{2}$. The trick is to guess $d$, such that $\frac{c+d}{2}=\frac{a+b}{2}$.
\end{document}
